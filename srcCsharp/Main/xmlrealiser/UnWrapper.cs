/*
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is "Simplenlg".
 *
 * The Initial Developer of the Original Code is Ehud Reiter, Albert Gatt and Dave Westwater.
 * Portions created by Ehud Reiter, Albert Gatt and Dave Westwater are Copyright (C) 2010-11 The University of Aberdeen. All Rights Reserved.
 *
 * Contributor(s): Ehud Reiter, Albert Gatt, Dave Wewstwater, Roman Kutlak, Margaret Mitchell.
 *
 * Ported to C# by Gert-Jan de Vries
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml.Serialization;
using SimpleNLG.Main.features;

namespace SimpleNLG.Main.xmlrealiser
{


	using ClauseStatus = ClauseStatus;
	using DiscourseFunction = DiscourseFunction;
	using Feature = Feature;
	using Form = Form;
	using Inflection = Inflection;
	using InternalFeature = InternalFeature;
	using LexicalFeature = LexicalFeature;
	using Person = Person;
	using Tense = Tense;
	using CoordinatedPhraseElement = framework.CoordinatedPhraseElement;
	using DocumentCategory = framework.DocumentCategory;
	using DocumentElement = framework.DocumentElement;
	using ElementCategory = framework.ElementCategory;
	using InflectedWordElement = framework.InflectedWordElement;
	using LexicalCategory = framework.LexicalCategory;
	using NLGElement = framework.NLGElement;
	using NLGFactory = framework.NLGFactory;
	using PhraseCategory = framework.PhraseCategory;
	using PhraseElement = framework.PhraseElement;
	using WordElement = framework.WordElement;
	using Lexicon = lexicon.Lexicon;
	using AdjPhraseSpec = phrasespec.AdjPhraseSpec;
	using AdvPhraseSpec = phrasespec.AdvPhraseSpec;
	using NPPhraseSpec = phrasespec.NPPhraseSpec;
	using PPPhraseSpec = phrasespec.PPPhraseSpec;
	using SPhraseSpec = phrasespec.SPhraseSpec;
	using VPPhraseSpec = phrasespec.VPPhraseSpec;
	using XmlWordElement = wrapper.XmlWordElement;

	// TODO: Auto-generated Javadoc
    /**
     * UnWrapper maps from classes generated by xjc from RealizerSchema.xsd to
     * SimpleNLG classes. There are classes of the same name in two packages. The
     * xjc wrapper classes are in the simplenlg.xmlrealiser.wrapper package, and are
     * prefixed with the package name. The real simplenlg classes are referenced
     * without package name prefix.
     * 
     * @author Christopher Howell Agfa Healthcare Corporation
     * @author Albert Gatt, University of Malta
     * 
     */
	public class UnWrapper
	{
	    /**
	     * Create wrapper objects from xml for a request to realise, or the xml for
	     * a recording. Both are elements of NLGSpec.
	     * 
	     * @param xmlReader
	     *            the xml reader
	     * @return the nLG spec
	     * @throws XMLRealiserException
	     *             the xML realiser exception
	     */
		public static wrapper.NLGSpec getNLGSpec(StringReader xmlReader)
		{
			wrapper.NLGSpec wt = null;
			try
			{
                XmlSerializer serializer = new XmlSerializer(typeof(wrapper.NLGSpec));
			    object obj = serializer.Deserialize(xmlReader);

				if (obj is wrapper.NLGSpec)
				{
					wt = (wrapper.NLGSpec) obj;
				}
			}

			catch (Exception e)
			{
				throw new XMLRealiserException("XML deserialization error", e);
			}

			return wt;
		}

	    /** The factory. */
		internal NLGFactory factory = null;

	    /**
	     * Initialise an UnWrapper with a lexicon.
	     * 
	     * @param lexicon
	     *            the lexicon to use
	     */
		public UnWrapper(Lexicon lexicon)
		{
			factory = new NLGFactory(lexicon);
		}

	    /**
	     * Create simplenlg objects from wrapper objects.
	     * 
	     * @param wt
	     *            the wrapper DocumentElement object
	     * @return the document element
	     */
		public virtual DocumentElement UnwrapDocumentElement(wrapper.XmlDocumentElement wt)
		{
			DocumentElement t = factory.createDocument();

			if (wt.Cat != null)
			{
			    Enum.TryParse(wt.Cat.ToString(), out DocumentCategory.DocumentCategoryEnum cat);
			    t.Category = new DocumentCategory(cat);
			}
			if (wt.Title != null)
			{
				t.Title = wt.Title;
			}

			foreach (wrapper.XmlNLGElement wp in wt.Child)
			{
				NLGElement p = UnwrapNLGElement(wp);
				t.addComponent(p);
			}

			return t;
		}

	    /**
	     * Unwrap a <code>simplenlg.xmlrealiser.wrapper.NLGElement</code> and map it
	     * to a <code>simplenlg.framework.NLGElement</code>
	     * 
	     * @param wps
	     *            The wrapper object
	     * @return the NLGElement
	     */
		public virtual NLGElement UnwrapNLGElement(wrapper.XmlNLGElement wps)
		{

			if (wps == null)
			{
				return null;
			}

			if (wps is wrapper.XmlDocumentElement)
			{
				return (NLGElement) UnwrapDocumentElement((wrapper.XmlDocumentElement) wps);
			}

		    // Handle coordinate phrase specs first, which will cause recursion.
			NLGElement cp = UnwrapCoordinatePhraseSpec(wps);
			if (cp != null)
			{
				return cp;
			}

		    // Literal text.
			if (wps is wrapper.XmlStringElement)
			{
				wrapper.XmlStringElement wp = (wrapper.XmlStringElement) wps;
				NLGElement p = factory.createStringElement(wp.Val);
				return p;
			}

		    // WordElements (delegate to UnwrapWordElement) -- useful to have
		    // because it is called by unWrapPhraseComponents, and pre/post mods
		    // might be WordElements
			if (wps is XmlWordElement)
			{
				return UnwrapWordElement((XmlWordElement) wps);
			}

		    // Sentence
			else if (wps is wrapper.XmlSPhraseSpec)
			{
				wrapper.XmlSPhraseSpec wp = (wrapper.XmlSPhraseSpec) wps;
				SPhraseSpec sp = factory.createClause();
				NLGElement vp = null;

				List<NLGElement> subjects = new List<NLGElement>();
				foreach (wrapper.XmlNLGElement p in wp.Subj)
				{
					NLGElement p1 = UnwrapNLGElement(p);
					checkFunction(DiscourseFunction.SUBJECT, p1);
					subjects.Add(p1);
				}

				if (subjects.Any())
				{
					sp.setFeature(InternalFeature.SUBJECTS, subjects);
				}

				if (wp.Vp != null)
				{
					vp = UnwrapNLGElement(wp.Vp);
					sp.VerbPhrase = vp;
				}

				if (wp.CuePhrase != null)
				{
					NLGElement cue = UnwrapNLGElement(wp.CuePhrase);
					cue.setFeature(InternalFeature.DISCOURSE_FUNCTION, DiscourseFunction.CUE_PHRASE);
					sp.setFeature(Feature.CUE_PHRASE, cue);
				}

				if (wp.COMPLEMENTISER != null)
				{
					sp.setFeature(Feature.COMPLEMENTISER, wp.COMPLEMENTISER);
				}

				setSFeatures(wp, sp, vp);

			    // Common phrase components.
				UnwrapPhraseComponents(sp, wps);

				return sp;
			}

		    // Phrases
			else if (wps is wrapper.XmlPhraseElement)
			{
				wrapper.XmlPhraseElement we = (wrapper.XmlPhraseElement) wps;
				PhraseElement hp = null;
				XmlWordElement w = we.Head;
				NLGElement head = UnwrapWordElement(w);

			    // NLGElement head;
			    // simplenlg.xmlrealiser.wrapper.XmlNLGElement w =
			    // we.getHeadstring();

			    // check whether we have a stringelement or wordelement as head
			    // if(w == null) {
			    // w = we.getHeadword();
			    // head = UnwrapWordElement((XmlWordElement) w);
			    //				
			    // } else {
			    // head = factory.createStringElement(((XmlStringElement)
			    // w).getVal());
			    // }

			    // Noun Phrase
				if (wps is wrapper.XmlNPPhraseSpec)
				{
					wrapper.XmlNPPhraseSpec wp = (wrapper.XmlNPPhraseSpec) wps;

					NPPhraseSpec p = factory.createNounPhrase(head);
					hp = p;

					if (wp.Spec != null)
					{
					    // p.setSpecifier(UnwrapWordElement(wp.getSpec()));
						wrapper.XmlNLGElement spec = wp.Spec;

						if (spec is XmlWordElement)
						{
							WordElement specifier = (WordElement) UnwrapWordElement((XmlWordElement) spec);

							if (specifier != null)
							{
								p.setSpecifier(specifier);
							}

						}
						else
						{
							p.setSpecifier(UnwrapNLGElement(spec));
						}
					}

					setNPFeatures(wp, p);
				}

			    // Adjective Phrase
				else if (wps is wrapper.XmlAdjPhraseSpec)
				{
					wrapper.XmlAdjPhraseSpec wp = (wrapper.XmlAdjPhraseSpec) wps;
					AdjPhraseSpec p = factory.createAdjectivePhrase(head);
					hp = p;

					p.setFeature(Feature.IS_COMPARATIVE, wp.ISCOMPARATIVE);
					p.setFeature(Feature.IS_SUPERLATIVE, wp.ISSUPERLATIVE);
				}

			    // Prepositional Phrase
				else if (wps is wrapper.XmlPPPhraseSpec)
				{
					PPPhraseSpec p = factory.createPrepositionPhrase(head);
					hp = p;
				}

			    // Adverb Phrase
				else if (wps is wrapper.XmlAdvPhraseSpec)
				{
					wrapper.XmlAdvPhraseSpec wp = (wrapper.XmlAdvPhraseSpec) wps;
					AdvPhraseSpec p = factory.createAdverbPhrase();
					p.setHead(head);
					hp = p;
					p.setFeature(Feature.IS_COMPARATIVE, wp.ISCOMPARATIVE);
					p.setFeature(Feature.IS_SUPERLATIVE, wp.ISSUPERLATIVE);
				}

			    // Verb Phrase
				else if (wps is wrapper.XmlVPPhraseSpec)
				{
					wrapper.XmlVPPhraseSpec wp = (wrapper.XmlVPPhraseSpec) wps;
					VPPhraseSpec p = factory.createVerbPhrase(head);
					hp = p;
					setVPFeatures(wp, p);
				}

			    // Common phrase components.
				UnwrapPhraseComponents(hp, wps);

			    // set the discourse function, if defined
				if (we.DiscourseFunction != null)
				{
				    DiscourseFunction func;
				    Enum.TryParse(we.DiscourseFunction.ToString(), out func);
					hp.setFeature(InternalFeature.DISCOURSE_FUNCTION, func);
				}

			    // check the appositive feature
				bool? appositive = we.Appositive;
				if (appositive != null)
				{
					hp.setFeature(Feature.APPOSITIVE, appositive);
				}

				return hp;
			}

			return null;
		}

	    /**
	     * Unwrap the common phrase components (premodifiers, postmodifiers etc)
	     * that any <code>simplenlg.xmlrealiser.wrapper.NLGElement</code> can have,
	     * and map it to a <code>simplenlg.framework.NLGElement</code>
	     * 
	     * @param hp
	     *            the <code>simplenlg.framework.NLGElement</code> which is
	     *            cuurrently being constructed
	     * @param wps
	     *            The wrapper object
	     */
		public virtual void UnwrapPhraseComponents(PhraseElement hp, wrapper.XmlNLGElement wps)
		{

			if (hp != null && wps != null)
			{
				wrapper.XmlPhraseElement wp = (wrapper.XmlPhraseElement) wps;

				foreach (wrapper.XmlNLGElement p in wp.FrontMod)
				{
					NLGElement p1 = UnwrapNLGElement(p);
					checkFunction(DiscourseFunction.FRONT_MODIFIER, p1);

					if (p1 != null)
					{
						hp.addFrontModifier(p1);
					}
				}

				foreach (wrapper.XmlNLGElement p in wp.PreMod)
				{
					NLGElement p1 = UnwrapNLGElement(p);
					checkFunction(DiscourseFunction.PRE_MODIFIER, p1);

					if (p1 != null)
					{
						hp.addPreModifier(p1);
					}
				}

				foreach (wrapper.XmlNLGElement p in wp.PostMod)
				{
					NLGElement p1 = UnwrapNLGElement(p);
					checkFunction(DiscourseFunction.POST_MODIFIER, p1);

					if (p1 != null)
					{
						hp.addPostModifier(p1);
					}
				}

				foreach (wrapper.XmlNLGElement p in wp.Compl)
				{
					NLGElement p1 = UnwrapNLGElement(p);

				    // NB: set function to object by default, unless user set
					checkFunction(DiscourseFunction.OBJECT, p1);

					if (p1 != null)
					{
						hp.addComplement(p1);
					}
				}
			}
		}

	    /**
	     * Unwraps a coordinate phrase.
	     * 
	     * @param wps
	     *            the <code>simplenlg.xmlrealiser.wrapper.NLGElement</code>
	     *            representing the phrase
	     * @return a <code>simplenlg.framework.CoordinatedPhraseElement</code> or
	     *         <code>null</code> if the wrapper element is not a coordinate
	     *         phrase.
	     */
		public virtual NLGElement UnwrapCoordinatePhraseSpec(wrapper.XmlNLGElement wps)
		{
			NLGElement ret = null;

		    // CoordinatedPhraseElement
			if (wps is wrapper.XmlCoordinatedPhraseElement)
			{
				wrapper.XmlCoordinatedPhraseElement wp = (wrapper.XmlCoordinatedPhraseElement) wps;
				CoordinatedPhraseElement cp = new CoordinatedPhraseElement();
				ElementCategory cat = UnwrapCategory(wp.Cat);

				if (cat != null && cat is PhraseCategory)
				{
					cp.Category = cat;
				}
				if (wp.Conj != null)
				{
					string s = wp.Conj;
					if (!ReferenceEquals(s, null))
					{
						cp.Conjunction = s;
					}
				}

				setCoordinatedPhraseFeatures(wp, cp);

				foreach (wrapper.XmlNLGElement p in wp.Coord)
				{
					NLGElement p1 = UnwrapNLGElement(p);
					if (p1 != null)
					{
						cp.addCoordinate(p1);
					}

				}
				ret = cp;
			}

			return ret;
		}

	    /**
	     * Unwrap word element.
	     * 
	     * @param wordElement
	     *            the word element
	     * @return the nLG element
	     */
		private NLGElement UnwrapWordElement(XmlWordElement wordElement)
		{
			NLGElement word = null;

			if (wordElement != null)
			{

				if (true.Equals(wordElement.Canned))
				{
					word = factory.createStringElement(wordElement.Base);

				}
				else
				{

					LexicalCategory lexCat = new LexicalCategory(LexicalCategory.LexicalCategoryEnum.ANY);
					ElementCategory cat = UnwrapCategory(wordElement.Cat);

					if (cat != null && cat is LexicalCategory)
					{
						lexCat = (LexicalCategory) cat;
					}

				    // String baseForm = getBaseWord(wordElement);
					string baseForm = wordElement.Base;

					if (!ReferenceEquals(baseForm, null))
					{
						word = factory.createWord(baseForm, lexCat);

						if (word is InflectedWordElement && ((InflectedWordElement) word).BaseWord.BaseForm.Length==0)
						{
							word = null; // cch TESTING

						}
						else if (word is WordElement)
						{
							WordElement we = (WordElement) word;

						    // Inflection
							if (wordElement.Var != null)
							{
                                Enum.TryParse(wordElement.Var.ToString(), out Inflection defaultInflection);
								we.setDefaultInflectionalVariant(defaultInflection);
							}

						    // Spelling variant may have been given as base form in xml.
						    // If so, use that variant.
							if (!Regex.IsMatch(baseForm,"^"+we.BaseForm+"$"))
							{
								we.DefaultSpellingVariant = baseForm;
							}
						}
					}
				}
			}

			return word;
		}

	    // String getBaseWord(simplenlg.xmlrealiser.wrapper.WordElement lex) {
	    // // List<String> c = lex.getContent();
	    // // if (c.isEmpty())
	    // // return "";
	    // // else
	    // // return (String) c.get(0);
	    // return lex.getBase();
	    //
	    // }

	    /**
	     * Unwrap category.
	     * 
	     * @param cat
	     *            the xml category object
	     * @return the element category
	     */
		private ElementCategory UnwrapCategory(object cat)
		{
			if (cat == null)
			{
				return null;
			}
			if (cat.GetType().Equals(typeof(wrapper.XmlLexicalCategory)))
			{
			    Enum.TryParse(cat.ToString(), out LexicalCategory.LexicalCategoryEnum lexCat);
			    return new LexicalCategory(lexCat);
			}
			else if (cat.GetType().Equals(typeof(wrapper.XmlPhraseCategory)))
			{
			    Enum.TryParse(cat.ToString(), out PhraseCategory.PhraseCategoryEnum phraseCat);
                return new PhraseCategory(phraseCat);
			}
			else if (cat.GetType().Equals(typeof(wrapper.XmlDocumentCategory)))
			{
			    Enum.TryParse(cat.ToString(), out DocumentCategory.DocumentCategoryEnum docCat);
                return new DocumentCategory(docCat);
			}
			else
			{
				return null;
			}
		}

	    /**
	     * Sets coordinated phrase features.
	     * 
	     * @param wp
	     *            The xml CoordinatedPhraseElement object.
	     * @param p
	     *            the internal CoordinatedPhraseElement object to get the features.
	     */
		private void setCoordinatedPhraseFeatures(wrapper.XmlCoordinatedPhraseElement wp, CoordinatedPhraseElement p)
		{

			if (wp.PERSON != null)
			{
				p.setFeature(Feature.PERSON, wp.PERSON);
			}

			if (wp.TENSE != null)
			{
			    Enum.TryParse(wp.TENSE.ToString(), out Tense tense);
				p.setFeature(Feature.TENSE, tense);
			}

			if (wp.MODAL != null)
			{
				p.setFeature(Feature.MODAL, wp.MODAL);
			}

			if (wp.NUMBER != null)
			{ // map number feature from wrapper ~NumberAgr to actual NumberAgr
				string numString = wp.NUMBER.ToString();
				Enum.TryParse(numString, out NumberAgreement simplenlgNum);
			    // p.setFeature(Feature.NUMBER, wp.getNUMBER());
				p.setFeature(Feature.NUMBER, simplenlgNum);
			}

			if (wp.PERSON != null)
			{ // map person feature from wrapper Person to actual Person
				string perString = wp.PERSON.ToString();
				Enum.TryParse(perString,out Person simplenlgPers);
				p.setFeature(Feature.PERSON, simplenlgPers);
			}

		    // boolean features.
			p.setFeature(Feature.APPOSITIVE, wp.APPOSITIVE);
			p.setFeature(Feature.NEGATED, wp.NEGATED);
			p.setFeature(Feature.POSSESSIVE, wp.POSSESSIVE);
			p.setFeature(Feature.PROGRESSIVE, wp.PROGRESSIVE);
			p.setFeature(Feature.RAISE_SPECIFIER, wp.RAISESPECIFIER);
			p.setFeature(Feature.SUPRESSED_COMPLEMENTISER, wp.SUPRESSEDCOMPLEMENTISER);
		}
	    /**
	     * Sets the np features.
	     * 
	     * @param wp
	     *            The xml Noun Phrase object.
	     * @param p
	     *            the NPPhraseSpec object to get the features.
	     */
		private void setNPFeatures(wrapper.XmlNPPhraseSpec wp, NPPhraseSpec p)
		{

			if (wp.NUMBER != null)
			{
			    // map number feature from wrapper ~NumberAgr to actual NumberAgr
				string numString = wp.NUMBER.ToString();
				Enum.TryParse(numString, out NumberAgreement simplenlgNum);
			    // p.setFeature(Feature.NUMBER, wp.getNUMBER());
				p.setFeature(Feature.NUMBER, simplenlgNum);
			}

			if (wp.PERSON != null)
			{
			    // map person feature from wrapper Person to actual Person
				string perString = wp.PERSON.ToString();
				Enum.TryParse(perString, out Person simplenlgPers);
				p.setFeature(Feature.PERSON, simplenlgPers);
			}

			if (wp.GENDER != null)
			{
			    // map gender feature from wrapper Gender to actual Gender
				string genString = wp.GENDER.ToString();
				Enum.TryParse(genString, out Gender simplenlgGen);
				p.setFeature(LexicalFeature.GENDER, simplenlgGen);
			}

			p.setFeature(Feature.ELIDED, wp.ELIDED);
			p.setFeature(Feature.POSSESSIVE, wp.POSSESSIVE);
			p.setFeature(Feature.PRONOMINAL, wp.PRONOMINAL);

		}

	    /**
	     * Sets the vp features.
	     * 
	     * @param wp
	     *            The xml Verb Phrase object.
	     * @param p
	     *            the internal VP object to get features from xml object.
	     */
		private void setVPFeatures(wrapper.XmlVPPhraseSpec wp, VPPhraseSpec p)
		{
			if (wp.FORM != null)
			{
			    Enum.TryParse(wp.FORM.ToString(), out Form form);
				p.setFeature(Feature.FORM, form);
			}

			if (wp.PERSON != null)
			{
				p.setFeature(Feature.PERSON, wp.PERSON);
			}

			if (wp.TENSE != null)
			{
			    Enum.TryParse(wp.TENSE.ToString(), out Form tense);
                p.setFeature(Feature.TENSE, tense);
			}

			if (wp.MODAL != null)
			{
				p.setFeature(Feature.MODAL, wp.MODAL);
			}

			p.setFeature(Feature.AGGREGATE_AUXILIARY, wp.AGGREGATEAUXILIARY);
			p.setFeature(Feature.NEGATED, wp.NEGATED);
			p.setFeature(Feature.PASSIVE, wp.PASSIVE);
			p.setFeature(Feature.PERFECT, wp.PERFECT);
			p.setFeature(Feature.PROGRESSIVE, wp.PROGRESSIVE);
			p.setFeature(Feature.SUPPRESS_GENITIVE_IN_GERUND, wp.SUPPRESSGENITIVEINGERUND);
			p.setFeature(Feature.SUPRESSED_COMPLEMENTISER, wp.SUPRESSEDCOMPLEMENTISER);
		}

	    /**
	     * ~Set the features for a sentence. This method also checks whether any
	     * features have been set on the VP, in which case, they are set if they
	     * haven't been set on the S
	     * 
	     * @param wp
	     *            the xml SPhraseSpec object
	     * @param sp
	     *            the sentence.
	     * @param vp
	     *            the verb phrase.
	     */
		private void setSFeatures(wrapper.XmlSPhraseSpec wp, SPhraseSpec sp, NLGElement vp)
		{

			if (wp.CLAUSESTATUS != null)
			{
			    Enum.TryParse(wp.CLAUSESTATUS.ToString(), out ClauseStatus clauseStatus);
                sp.setFeature(InternalFeature.CLAUSE_STATUS, clauseStatus);
			}

			if (wp.PERSON != null)
			{
			    Enum.TryParse(wp.PERSON.ToString(), out Person person);
                sp.setFeature(Feature.PERSON, person);
			}

			if (wp.FORM != null)
			{
			    Enum.TryParse(wp.FORM.ToString(), out Form form);
                sp.setFeature(Feature.FORM, form);
			}

			if (wp.TENSE != null)
			{
			    Enum.TryParse(wp.TENSE.ToString(), out Form tense);
                sp.setFeature(Feature.TENSE, tense);

			}
			else if (vp != null && vp.hasFeature(Feature.TENSE))
			{
				sp.setFeature(Feature.TENSE, vp.getFeature(Feature.TENSE));
			}

		    // modal -- set on S or inherited from VP
			if (wp.MODAL != null)
			{
				sp.setFeature(Feature.MODAL, wp.MODAL);
			}
			else if (vp != null && vp.hasFeature(Feature.MODAL))
			{
				sp.setFeature(Feature.MODAL, vp.getFeature(Feature.MODAL));
			}

		    // interrogative
			if (wp.INTERROGATIVETYPE != null)
			{
			    Enum.TryParse(wp.INTERROGATIVETYPE.ToString(), out InterrogativeType interrogativeType);
                sp.setFeature(Feature.INTERROGATIVE_TYPE, interrogativeType);
			}
			else if (vp != null && vp.hasFeature(Feature.INTERROGATIVE_TYPE))
			{
				sp.setFeature(Feature.INTERROGATIVE_TYPE, vp.getFeature(Feature.INTERROGATIVE_TYPE));
			}

		    // set on clauses.
			bool sAggregateAuxiliary = wp.AGGREGATEAUXILIARY ?? false;
			bool vAggregateAuxiliary = vp?.getFeatureAsBoolean(Feature.AGGREGATE_AUXILIARY) ?? false;
			sp.setFeature(Feature.AGGREGATE_AUXILIARY, sAggregateAuxiliary || vAggregateAuxiliary);

		    // passive: can be set on S or VP
			bool sPass = wp.PASSIVE ?? false;
			bool vPass = vp?.getFeatureAsBoolean(Feature.PASSIVE) ?? false;
			sp.setFeature(Feature.PASSIVE, sPass || vPass);

		    // progressive: can be set on S or VP
			bool sProg = wp.PROGRESSIVE ?? false;
			bool vProg = vp?.getFeatureAsBoolean(Feature.PROGRESSIVE) ?? false;
			sp.setFeature(Feature.PROGRESSIVE, sProg || vProg);

		    // perfect: can be set on S or VP
			bool sPerf = wp.PERFECT ?? false;
			bool vPerf = vp?.getFeatureAsBoolean(Feature.PERFECT) ?? false;
			sp.setFeature(Feature.PERFECT, sPerf || vPerf);

		    // negation: can be set on S or VP
			bool sNeg = wp.NEGATED ?? false;
			bool vNeg = vp?.getFeatureAsBoolean(Feature.NEGATED) ?? false;
			sp.setFeature(Feature.NEGATED, sNeg || vNeg);

		    // set on clauses.
			bool ssgg = wp.SUPPRESSGENITIVEINGERUND ?? false;
			bool vsgg = vp?.getFeatureAsBoolean(Feature.SUPPRESS_GENITIVE_IN_GERUND) ?? false;
			sp.setFeature(Feature.SUPPRESS_GENITIVE_IN_GERUND, ssgg || vsgg);

		    // set on clauses.
			bool ssc = wp.SUPRESSEDCOMPLEMENTISER ?? false;
			bool vsc = vp?.getFeatureAsBoolean(Feature.SUPRESSED_COMPLEMENTISER) ?? false;
			sp.setFeature(Feature.SUPRESSED_COMPLEMENTISER, ssc || vsc);

		}

	    /**
	     * Utility method to set the discourse function for phrase components,
	     * unless set by user
	     * 
	     * @param function
	     *            the function
	     * @param phrase
	     *            the phrase
	     */
		private void checkFunction(DiscourseFunction function, NLGElement phrase)
		{
			if (!phrase.hasFeature(InternalFeature.DISCOURSE_FUNCTION))
			{
				phrase.setFeature(InternalFeature.DISCOURSE_FUNCTION, function);
			}
		}
	}

}